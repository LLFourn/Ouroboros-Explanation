# The players
sub term:<ğŸ§‘ğŸ»> { 'Alice' }
sub term:<ğŸ§”ğŸ¾> { 'Rob'  }
constant &print-hex := '0x' ~ *.base(16).lc;
# Used to print clearly what is actually being sent between the parties
sub infix:<âŸ¹>($sender, %message) {
    my constant GREEN      = "\e[32m";
    my constant RESET      = "\e[0m";
    my $header =  ">>>=====$sender sends====>>>";
    say GREEN ~ $header ~ RESET;
    say %message.map({ "{.key}: {.value ~~ Int ?? .value.&print-hex !! .value}"}).join("\n");
    say GREEN ~ ('=' x $header.chars) ~ RESET;
}

enum Coin <Heads Tails>;

# Taken from https://tools.ietf.org/html/rfc3526#page-3
constant \ğ’‘ = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF;
constant \ğ’’ = (ğ’‘ - 1) div 2;
constant \ğ’ˆ = 2;
# The ranges
constant $â„¤ğ’‘ = ^ğ’‘; # Perl 6 for 0..(ğ’‘-1);
constant $â„¤ğ’’ = ^ğ’’;
# The types derived from the ranges
subset â„¤ğ’‘ of Int:D where $â„¤ğ’‘;
subset â„¤ğ’’ of Int:D where $â„¤ğ’’;
# The multiplicative group of order ğ’’ ( generated by ğ’ˆ )
subset ğ”¾ of â„¤ğ’‘ where *.&expmod(ğ’’, ğ’‘) == 1;
# define new operator âŠ• as bitwise xor
constant &infix:<âŠ•> := &[+^];

sub read-line {
    my $res = $*IN.get();
    $*OUT.print("\e[A\r" ~ 'X' x 40 ~ ' ' x ($res.chars - 40) ~ "\n");
    return $res;
}

sub secret-prompt($msg, :$validity-check = True){
    say $msg;
    my $res = read-line();
    # Read a line from STDIN
    until $res ~~ $validity-check {
        say "invalid value - must match {$validity-check.gist}. Try again.";
        $res = read-line();
    }
    # Put n number of Xs over the previous line
    return $res;
}

sub CHOOSE-MOVE($player --> Coin) {
    say "$player, choose an outcome.";
    secret-prompt(
        '[H]eads or [T]ails?',
        parse => { Coin::.values.first(*.starts-with(.uc)) }
    );
}

sub CHOOSE-RANDOMNESS($player --> â„¤ğ’’) {
    my $randomness = secret-prompt(
        "$player, behave [H]onestly? or enter your own integer:",
        validity-check => /^ H | (.+) <?{ quietly try $/.Int ~~ â„¤ğ’’ }> $/,
    );

    return do given $randomness {
                 # Clever way of ensuring we don't get powers of two or 0
                 # Check if the least signigicant bit is the same as the
                 # most significant bit.
        when 'H' { $â„¤ğ’’.roll(*).first({ .lsb !~~ .msb }) }
        default { .Int }
    }
}

sub COMMIT(â„¤ğ’’ \ğ’™ --> ğ”¾) { expmod(ğ’ˆ, ğ’™, ğ’‘) }

sub CLAIM($player) {
    # cheating
    my $randomness = secret-prompt(
        "$player, what do you claim your randomness was?" ~
        "\n([H] to use the true value)",
        validity-check => /^ H | .+ <?{ quietly try $/.Int ~~ $â„¤ğ’’ }> $/
    );
    given $randomness {
        when 'H' { $randomness = $*HINT }
        default  { .Int }
    }
    return $randomness;
}

sub CHECK-RESULT($alice-move, $random-number) {
    my $even = $random-number %% 2;
    my $coin-toss = Coin($odd);
    my $result = $alice-move eq $coin-toss;

    say "============";
    say "The final random number is:\n{$random-number.&print-hex}";
    say "Which is { $even ?? 'even' !! 'odd' }. So, the coin-toss resulted in $coin-toss.";
    say "Alice chose $alice-move, so { $result ?? ğŸ§‘ğŸ» !! ğŸ§”ğŸ¾} wins!", ;
}

# Entrypoint
sub MAIN {
    # Keep a hint around so Alice doesn't have to remember her number
    my $*HINT;
    # Prompt alice for heads or tails;
    my Coin \ğ‘š = CHOOSE-MOVE(ğŸ§‘ğŸ»);

    my ğ”¾ \ğ’„ = do {
        # Prompt alice for her randomness
        $*HINT = my â„¤ğ’’ \ğ’”â‚ = CHOOSE-RANDOMNESS(ğŸ§‘ğŸ»);
        # Return the resulting commitment
        COMMIT(ğ’”â‚);
    }

    # Send the commitment and the move in the clear to Rob
    ğŸ§‘ğŸ» âŸ¹  { commitment => ğ’„, move => ğ‘š };

    # Rob doesn't have to choose a move, his move is just the opposite of Alice's
    my â„¤ğ’’ \ğ’”áµ£ = CHOOSE-RANDOMNESS(ğŸ§”ğŸ¾);
    ğŸ§”ğŸ¾ âŸ¹ { randomness => ğ’”áµ£ };

    my â„¤ğ’’ \ğ’”â‚Ê¹ = CLAIM(ğŸ§‘ğŸ»);
    ğŸ§‘ğŸ» âŸ¹  { randomness => ğ’”â‚Ê¹ };

    my ğ”¾ \ğ’„Ê¹ = COMMIT(ğ’”â‚Ê¹);

    if ğ’„Ê¹ eq  ğ’„ {
        say "{ğŸ§‘ğŸ»}'s claim is the same as her commitment.";
        my \ğ’” = ğ’”áµ£ âŠ• ğ’”â‚Ê¹;
        CHECK-RESULT(ğ‘š, ğ’”);
    }
    else {
        say "{ğŸ§‘ğŸ»}'s claim: {ğ’„Ê¹.&print-hex}";
        say "{ğŸ§‘ğŸ»} is lying! Her claim is not the same as her commitment.";
        say "{ğŸ§”ğŸ¾} wins by default!";
    }
}
