# The players
enum Player <Alice Rob>;

constant \term:<ğŸ§‘ğŸ»> = Alice;
constant \term:<ğŸ§”ğŸ¾> = Rob;

enum Coin <Heads Tails>;

# Taken from https://tools.ietf.org/html/rfc3526#page-3
constant \ğ‘ = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF;
constant \ğ‘ = (ğ‘ - 1) div 2;
constant \ğ‘” = 2;
# The ranges
constant $â„¤ğ‘ = ^ğ‘; # Perl 6 for 0..(ğ‘-1);
constant $â„¤ğ‘ = ^ğ‘;

# The types derived from the ranges
subset â„¤ğ‘ of Int:D where $â„¤ğ‘;
subset â„¤ğ‘ of Int:D where $â„¤ğ‘;
# The multiplicative group of order ğ‘ ( generated by ğ‘” )
subset ğ”¾ of â„¤ğ‘ where *.expmod(ğ‘, ğ‘) == 1;
# define new operator âŠ• as bitwise xor
constant &infix:<âŠ•> := &[+^];

# Make Int gist as hex without affecting Enums
multi gist(Int:D $_) { '0x' ~ .base(16).lc }
multi gist(Enumeration:D $_) is default { .gist }

# Used to print clearly what is actually being sent between the parties
sub infix:<âŸ¹>(Player:D $sender, *@message) {
    my constant GREEN      = "\e[32m";
    my constant RESET      = "\e[0m";
    my $header =  ">>>=====$sender sends====>>>";
    my @body = @message.map({ "{.key}: {gist .value}"});

    say GREEN ~ $header ~ RESET;
    say @body.join("\n");
    say GREEN ~ ('=' x $header.chars) ~ RESET;
}

# Put 40 Xs over the previous line's input
sub read-line(-->Str:D) {
    my $line = $*IN.get();
    say "\e[A\r" ~ ('X' x 40) ~ (' ' x $line.chars - 40);
    return $line;
}

sub secret-prompt(&parse) {
    until defined my $valid = parse(read-line) {
        say("Invalid value. Try again.")
    }
    return $valid;
}

sub CHOOSE-MOVE(Player:D $player --> Coin:D) {
    say "$player, choose an outcome.";
    say '[H]eads or [T]ails?';
    secret-prompt({ Coin::.values.first(*.starts-with(.uc)) });
}

sub CHOOSE-RANDOMNESS(Player:D $player --> â„¤ğ‘) {
    say "$player, behave [H]onestly? or enter your own integer:";
    secret-prompt({
            when 'H' { $â„¤ğ‘.pick }
            default  { try quietly .Int }
    });
}

sub COMMIT(â„¤ğ‘ \ğ‘¥ --> ğ”¾) { expmod(ğ‘”, ğ‘¥, ğ‘) }

sub CLAIM(Player:D $player --> â„¤ğ‘) {
    say "$player, what do you claim your randomness was?";
    say "([H] to use the true value)";
    secret-prompt({
            when 'H' { $*HINT }
            default  { try quietly .Int  }
    });
}

sub CHECK-RESULT(Coin $alice-move, Int $random-number) {
    my $odd = ? $random-number % 2;
    my $coin-toss = Coin($odd);
    my $result = $alice-move eq $coin-toss;

    print qq:to/END/;
    ============
    The final random number is:\n{gist $random-number}
    Which is { $odd ?? 'odd' !! 'even' }. So, the coin-toss resulted in $coin-toss.
    Alice chose $alice-move, so { $result ?? ğŸ§‘ğŸ» !! ğŸ§”ğŸ¾} wins!
    END
}

# Entrypoint
sub MAIN {
    # Keep a hint around so Alice doesn't have to remember her number
    my $*HINT;
    # Prompt alice for heads or tails;
    my Coin \ğ‘š = CHOOSE-MOVE(ğŸ§‘ğŸ»);

    my ğ”¾ \ğ‘ = do {
        # Prompt alice for her randomness
        $*HINT = my â„¤ğ‘ \ğ‘ â‚ = CHOOSE-RANDOMNESS(ğŸ§‘ğŸ»);
        # Return the resulting commitment
        COMMIT(ğ‘ â‚);
    }

    # Alice sends her commitment and her move in the clear to Rob
    ğŸ§‘ğŸ» âŸ¹  ( commitment => ğ‘, move => ğ‘š );

    # Rob sends his randomness in the clear to Alice
    my â„¤ğ‘ \ğ‘ áµ£ = CHOOSE-RANDOMNESS(ğŸ§”ğŸ¾);
    ğŸ§”ğŸ¾ âŸ¹ ( randomness => ğ‘ áµ£ );

    # Alice sends her claim to Rob
    my â„¤ğ‘ \ğ‘ â‚Ê¹ = CLAIM(ğŸ§‘ğŸ»);
    ğŸ§‘ğŸ» âŸ¹  ( randomness => ğ‘ â‚Ê¹ );

    # Calculate what the commitment should be from the claim
    my ğ”¾ \ğ‘Ê¹ = COMMIT(ğ‘ â‚Ê¹);

    # Check they're the same
    if ğ‘Ê¹ eq  ğ‘ {
        say "{ğŸ§‘ğŸ»}'s claim is the same as her commitment.";
        my \ğ‘  = ğ‘ áµ£ âŠ• ğ‘ â‚Ê¹;
        CHECK-RESULT(ğ‘š, ğ‘ );
    }
    else {
        print qq:to/END/;
        say "{ğŸ§‘ğŸ»}'s claim: {gist ğ‘Ê¹}";
        say "{ğŸ§‘ğŸ»} is lying! Her claim is not the same as her commitment.";
        say "{ğŸ§”ğŸ¾} wins by default!";
        END
    }
}
