constant SHA256_DIGEST_LENGTH = 32;
use NativeCall;

sub SHA256(Blob, size_t, Blob) is native('ssl') { ... }
sub sha256(Blob $msg)  {
    my $digest = buf8.allocate(SHA256_DIGEST_LENGTH);
    SHA256($msg, $msg.bytes, $digest);
    return $digest;
}

# DLOG parameters
constant \𝑝 = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF;
constant \𝑞 = (𝑝 - 1) div 2;
constant \𝑔 = 2;
# The ranges
constant $ℤ𝑝 is export = ^𝑝; # Perl 6 for 0..(𝑝-1);
constant $ℤ𝑞 is export = ^𝑞;
# The types derived from the ranges
subset ℤ𝑝 of Int:D where $ℤ𝑝;
subset ℤ𝑞 of Int:D where $ℤ𝑞;
# The multiplicative group of order 𝑞 ( generated by 𝒈 )
subset 𝔾 of ℤ𝑝 where *.&expmod(𝑞, 𝑝) == 1;
# define new operator ⊕ as bitwise xor

#sub infix:<⊕> ($a,$b) is export { $a +^ $b }

subset SchnorrSig of Positional where :(ℤ𝑞, ℤ𝑞);
subset DLOG-keypair of Positional where :(ℤ𝑞, 𝔾);

# encode an integer big-endian into a Buf
sub int-to-buf(Int:D $int -->Buf:D) {
    my $i = ($int.msb // 0) div 8;
    Buf.new: (repeat { ($int +> ($i +< 3)) +& 0xff } until $i-- == 0);
}

# decode a big-endian integer into an Int
sub buf-to-int(Buf:D $buf --> Int:D) {
    my Int:D $int = 0;
    for $buf.kv -> $i, $byte {
        $int += ($byte +< ( ($buf.elems - 1 - $i) +< 3));
    }
    return $int;
}

sub 𝘏(Buf:D $input --> ℤ𝑞) {
    buf-to-int(sha256($input));
}

multi infix:<∥>(Int:D $a, Str:D $b --> Buf:D) {
    int-to-buf($a).append($b.encode('utf8'));
}

sub GEN(--> DLOG-keypair) is export
{
    my \𝑘 := $ℤ𝑞.pick;
    my \𝐾 := expmod(𝑔, 𝑘, 𝑝);
    return (𝑘, 𝐾);
}

sub SIGN(Str:D \𝑚, ℤ𝑞 \𝑘 --> SchnorrSig ) is export
{
    my \𝑟 := $ℤ𝑞.pick;
    my \𝑅 := expmod(𝑔, 𝑟, 𝑝);
    my \𝑐 := 𝘏(𝑅 ∥ 𝑚);
    my \𝑠 := (𝑟 + 𝑐*𝑘) mod 𝑞;
    return (𝑐, 𝑠);
}

sub VERIFY(SchnorrSig \𝜎, 𝔾 $pubkey, Str:D \𝑚 --> Bool:D) is export
{
    my (\𝑐, \𝑠) := 𝜎;
    my \𝑅 := (expmod($pubkey, -𝑐, 𝑝) * expmod(𝑔, 𝑠, 𝑝)) mod 𝑝;
    return 𝘏(𝑅 ∥ 𝑚) == 𝑐;
}

sub VALID-PUBKEY($pubkey --> Bool:D) is export {
    return $pubkey ~~ 𝔾
}


sub pick-ℤ𝑞 is export { $ℤ𝑞.pick }

sub COMMIT(ℤ𝑞 \𝑥 --> 𝔾) is export { expmod(𝑔, 𝑥, 𝑝) }

sub gen-private-key is export { $ℤ𝑞.pick }
