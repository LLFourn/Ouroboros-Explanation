constant SHA256_DIGEST_LENGTH = 32;
use NativeCall;

sub SHA256(Blob, size_t, Blob) is native('ssl') { ... }
sub sha256(Blob $msg)  {
    my $digest = buf8.allocate(SHA256_DIGEST_LENGTH);
    SHA256($msg, $msg.bytes, $digest);
    return $digest;
}

# DLOG parameters
constant \ğ‘ = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF;
constant \ğ‘ = (ğ‘ - 1) div 2;
constant \ğ‘” = 2;
# The ranges
constant $â„¤ğ‘ is export = ^ğ‘; # Perl 6 for 0..(ğ‘-1);
constant $â„¤ğ‘ is export = ^ğ‘;
# The types derived from the ranges
subset â„¤ğ‘ of Int:D where $â„¤ğ‘;
subset â„¤ğ‘ of Int:D where $â„¤ğ‘;
# The multiplicative group of order ğ‘ ( generated by ğ’ˆ )
subset ğ”¾ of â„¤ğ‘ where *.&expmod(ğ‘, ğ‘) == 1;
# define new operator âŠ• as bitwise xor

#sub infix:<âŠ•> ($a,$b) is export { $a +^ $b }

subset SchnorrSig of Positional where :(â„¤ğ‘, â„¤ğ‘);
subset DLOG-keypair of Positional where :(â„¤ğ‘, ğ”¾);

# encode an integer big-endian into a Buf
sub int-to-buf(Int:D $int -->Buf:D) {
    my $i = ($int.msb // 0) div 8;
    Buf.new: (repeat { ($int +> ($i +< 3)) +& 0xff } until $i-- == 0);
}

# decode a big-endian integer into an Int
sub buf-to-int(Buf:D $buf --> Int:D) {
    my Int:D $int = 0;
    for $buf.kv -> $i, $byte {
        $int += ($byte +< ( ($buf.elems - 1 - $i) +< 3));
    }
    return $int;
}

sub ğ˜(Buf:D $input --> â„¤ğ‘) {
    buf-to-int(sha256($input));
}

multi infix:<âˆ¥>(Int:D $a, Str:D $b --> Buf:D) {
    int-to-buf($a).append($b.encode('utf8'));
}

sub GEN(--> DLOG-keypair) is export
{
    my \ğ‘˜ := $â„¤ğ‘.pick;
    my \ğ¾ := expmod(ğ‘”, ğ‘˜, ğ‘);
    return (ğ‘˜, ğ¾);
}

sub SIGN(Str:D \ğ‘š, â„¤ğ‘ \ğ‘˜ --> SchnorrSig ) is export
{
    my \ğ‘Ÿ := $â„¤ğ‘.pick;
    my \ğ‘… := expmod(ğ‘”, ğ‘Ÿ, ğ‘);
    my \ğ‘ := ğ˜(ğ‘… âˆ¥ ğ‘š);
    my \ğ‘  := (ğ‘Ÿ + ğ‘*ğ‘˜) mod ğ‘;
    return (ğ‘, ğ‘ );
}

sub VERIFY(SchnorrSig \ğœ, ğ”¾ $pubkey, Str:D \ğ‘š --> Bool:D) is export
{
    my (\ğ‘, \ğ‘ ) := ğœ;
    my \ğ‘… := (expmod($pubkey, -ğ‘, ğ‘) * expmod(ğ‘”, ğ‘ , ğ‘)) mod ğ‘;
    return ğ˜(ğ‘… âˆ¥ ğ‘š) == ğ‘;
}

sub VALID-PUBKEY($pubkey --> Bool:D) is export {
    return $pubkey ~~ ğ”¾
}


sub pick-â„¤ğ‘ is export { $â„¤ğ‘.pick }

sub COMMIT(â„¤ğ‘ \ğ‘¥ --> ğ”¾) is export { expmod(ğ‘”, ğ‘¥, ğ‘) }

sub gen-private-key is export { $â„¤ğ‘.pick }
